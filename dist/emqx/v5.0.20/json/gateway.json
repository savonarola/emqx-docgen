[
  {
    "desc": "ClientInfo override.",
    "fields": [
      {
        "desc": "Template for overriding username.",
        "name": "username",
        "type": {
          "kind": "primitive",
          "name": "binary()"
        }
      },
      {
        "desc": "Template for overriding password.",
        "name": "password",
        "type": {
          "kind": "primitive",
          "name": "binary()"
        }
      },
      {
        "desc": "Template for overriding clientid.",
        "name": "clientid",
        "type": {
          "kind": "primitive",
          "name": "binary()"
        }
      }
    ],
    "full_name": "gateway:clientinfo_override",
    "paths": [
      "gateway.coap.clientinfo_override",
      "gateway.exproto.clientinfo_override",
      "gateway.lwm2m.clientinfo_override",
      "gateway.mqttsn.clientinfo_override",
      "gateway.stomp.clientinfo_override"
    ],
    "tags": [
      "Gateway"
    ]
  },
  {
    "desc": "The CoAP protocol gateway provides EMQX with the access capability of the CoAP protocol.\nIt allows publishing, subscribing, and receiving messages to EMQX in accordance\nwith a certain defined CoAP message format.",
    "fields": [
      {
        "default": {
          "hocon": "\"30s\"",
          "oneliner": true
        },
        "desc": "The gateway server required minimum heartbeat interval.\nWhen connection mode is enabled, this parameter is used to set the minimum heartbeat interval for the connection to be alive",
        "name": "heartbeat",
        "raw_default": "30s",
        "type": {
          "kind": "primitive",
          "name": "emqx_gateway_schema:duration()"
        }
      },
      {
        "default": {
          "hocon": "false",
          "oneliner": true
        },
        "desc": "Enable or disable connection mode.\nConnection mode is a feature of non-standard protocols. When connection mode is enabled, it is necessary to maintain the creation, authentication and alive of connection resources",
        "name": "connection_required",
        "raw_default": false,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "qos",
          "oneliner": true
        },
        "desc": "The Notification Message will be delivered to the CoAP client if a new message received on an observed topic.\nThe type of delivered coap message can be set to:<br/>\n  - non: Non-confirmable;<br/>\n  - con: Confirmable;<br/>\n  - qos: Mapping from QoS type of received message, QoS0 -> non, QoS1,2 -> con",
        "name": "notify_type",
        "raw_default": "qos",
        "type": {
          "kind": "enum",
          "symbols": [
            "non",
            "con",
            "qos"
          ]
        }
      },
      {
        "default": {
          "hocon": "coap",
          "oneliner": true
        },
        "desc": "The Default QoS Level indicator for subscribe request.\nThis option specifies the QoS level for the CoAP Client when establishing a subscription membership, if the subscribe request is not carried `qos` option. The indicator can be set to:<br/>\n  - qos0, qos1, qos2: Fixed default QoS level<br/>\n  - coap: Dynamic QoS level by the message type of subscribe request<br/>\n    * qos0: If the subscribe request is non-confirmable<br/>\n    * qos1: If the subscribe request is confirmable",
        "name": "subscribe_qos",
        "raw_default": "coap",
        "type": {
          "kind": "enum",
          "symbols": [
            "qos0",
            "qos1",
            "qos2",
            "coap"
          ]
        }
      },
      {
        "default": {
          "hocon": "coap",
          "oneliner": true
        },
        "desc": "The Default QoS Level indicator for publish request.\nThis option specifies the QoS level for the CoAP Client when publishing a message to EMQX PUB/SUB system, if the publish request is not carried `qos` option. The indicator can be set to:<br/>\n  - qos0, qos1, qos2: Fixed default QoS level<br/>\n  - coap: Dynamic QoS level by the message type of publish request<br/>\n    * qos0: If the publish request is non-confirmable<br/>\n    * qos1: If the publish request is confirmable",
        "name": "publish_qos",
        "raw_default": "coap",
        "type": {
          "kind": "enum",
          "symbols": [
            "qos0",
            "qos1",
            "qos2",
            "coap"
          ]
        }
      },
      {
        "default": {
          "hocon": "\"\"",
          "oneliner": true
        },
        "desc": "",
        "name": "mountpoint",
        "raw_default": "",
        "type": {
          "kind": "primitive",
          "name": "binary()"
        }
      },
      {
        "desc": "Settings for the UDP listeners.",
        "name": "listeners",
        "type": {
          "kind": "struct",
          "name": "gateway:udp_listeners"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Whether to enable this gateway",
        "name": "enable",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Whether to enable client process statistic",
        "name": "enable_stats",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "\"30s\"",
          "oneliner": true
        },
        "desc": "The idle time of the client connection process. It has two purposes:\n  1. A newly created client process that does not receive any client requests after that time will be closed directly.\n  2. A running client process that does not receive any client requests after this time will go into hibernation to save resources.",
        "name": "idle_timeout",
        "raw_default": "30s",
        "type": {
          "kind": "primitive",
          "name": "emqx_gateway_schema:duration()"
        }
      },
      {
        "desc": "ClientInfo override.",
        "name": "clientinfo_override",
        "type": {
          "kind": "struct",
          "name": "gateway:clientinfo_override"
        }
      },
      {
        "desc": "Default authentication configs for all the gateway listeners. For per-listener overrides see <code>authentication</code>\n in listener configs",
        "examples": {
          "jwt": {
            "summary": "JWT authentication",
            "value": {
              "algorithm": "hmac-based",
              "mechanism": "jwt",
              "secret": "mysecret",
              "secret_base64_encoded": false,
              "use_jwks": false,
              "verify_claims": {
                "username": "${username}"
              }
            }
          },
          "password_based:built_in_database": {
            "summary": "Built-in password_based authentication",
            "value": {
              "backend": "built_in_database",
              "mechanism": "password_based",
              "password_hash_algorithm": {
                "name": "sha256",
                "salt_position": "suffix"
              },
              "user_id_type": "username"
            }
          },
          "password_based:http": {
            "summary": "password_based authentication through external HTTP API",
            "value": {
              "backend": "http",
              "body": {
                "password": "${password}",
                "username": "${username}"
              },
              "connect_timeout": 5000,
              "enable_pipelining": 100,
              "headers": {
                "content-type": "application/json"
              },
              "mechanism": "password_based",
              "method": "post",
              "pool_size": 8,
              "request_timeout": 5000,
              "ssl": {
                "enable": false
              },
              "url": "http://127.0.0.1:18083"
            }
          },
          "password_based:mongodb": {
            "summary": "password_based authentication with MongoDB backend",
            "value": {
              "backend": "mongodb",
              "collection": "users",
              "database": "example",
              "filter": {
                "username": "${username}"
              },
              "is_superuser_field": "is_superuser",
              "mechanism": "password_based",
              "password_hash_algorithm": {
                "name": "sha256",
                "salt_position": "suffix"
              },
              "password_hash_field": "password_hash",
              "salt_field": "salt",
              "server": "127.0.0.1:27017"
            }
          },
          "password_based:redis": {
            "summary": "password_based authentication with Redis backend",
            "value": {
              "backend": "redis",
              "cmd": "HMGET ${username} password_hash salt",
              "database": 0,
              "mechanism": "password_based",
              "password_hash_algorithm": {
                "name": "sha256",
                "salt_position": "suffix"
              },
              "redis_type": "single",
              "server": "127.0.0.1:6379"
            }
          }
        },
        "name": "authentication",
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "struct",
              "name": "authn-builtin_db:authentication"
            },
            {
              "kind": "struct",
              "name": "authn-mysql:authentication"
            },
            {
              "kind": "struct",
              "name": "authn-postgresql:authentication"
            },
            {
              "kind": "struct",
              "name": "authn-mongodb:standalone"
            },
            {
              "kind": "struct",
              "name": "authn-mongodb:replica-set"
            },
            {
              "kind": "struct",
              "name": "authn-mongodb:sharded-cluster"
            },
            {
              "kind": "struct",
              "name": "authn-redis:standalone"
            },
            {
              "kind": "struct",
              "name": "authn-redis:cluster"
            },
            {
              "kind": "struct",
              "name": "authn-redis:sentinel"
            },
            {
              "kind": "struct",
              "name": "authn-http:get"
            },
            {
              "kind": "struct",
              "name": "authn-http:post"
            },
            {
              "kind": "struct",
              "name": "authn-jwt:hmac-based"
            },
            {
              "kind": "struct",
              "name": "authn-jwt:public-key"
            },
            {
              "kind": "struct",
              "name": "authn-jwt:jwks"
            },
            {
              "kind": "struct",
              "name": "authn-scram-builtin_db:authentication"
            }
          ]
        }
      }
    ],
    "full_name": "gateway:coap",
    "paths": [
      "gateway.coap"
    ],
    "tags": [
      "Gateway"
    ]
  },
  {
    "desc": "Settings for the DTLS listener.",
    "fields": [
      {
        "default": {
          "hocon": "16",
          "oneliner": true
        },
        "desc": "Size of the acceptor pool.",
        "name": "acceptors",
        "raw_default": 16,
        "type": {
          "kind": "primitive",
          "name": "integer()"
        }
      },
      {
        "name": "udp_options",
        "type": {
          "kind": "struct",
          "name": "gateway:udp_opts"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Enable the listener.",
        "name": "enable",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "desc": "The IP address and port that the listener will bind.",
        "name": "bind",
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "primitive",
              "name": "emqx_gateway_schema:ip_port()"
            },
            {
              "kind": "primitive",
              "name": "integer()"
            }
          ]
        }
      },
      {
        "default": {
          "hocon": "1024",
          "oneliner": true
        },
        "desc": "Maximum number of concurrent connections.",
        "name": "max_connections",
        "raw_default": 1024,
        "type": {
          "kind": "primitive",
          "name": "integer()"
        }
      },
      {
        "default": {
          "hocon": "1000",
          "oneliner": true
        },
        "desc": "Maximum connections per second.",
        "name": "max_conn_rate",
        "raw_default": 1000,
        "type": {
          "kind": "primitive",
          "name": "integer()"
        }
      },
      {
        "desc": "Default authentication configs for all the gateway listeners. For per-listener overrides see <code>authentication</code>\n in listener configs",
        "examples": {
          "jwt": {
            "summary": "JWT authentication",
            "value": {
              "algorithm": "hmac-based",
              "mechanism": "jwt",
              "secret": "mysecret",
              "secret_base64_encoded": false,
              "use_jwks": false,
              "verify_claims": {
                "username": "${username}"
              }
            }
          },
          "password_based:built_in_database": {
            "summary": "Built-in password_based authentication",
            "value": {
              "backend": "built_in_database",
              "mechanism": "password_based",
              "password_hash_algorithm": {
                "name": "sha256",
                "salt_position": "suffix"
              },
              "user_id_type": "username"
            }
          },
          "password_based:http": {
            "summary": "password_based authentication through external HTTP API",
            "value": {
              "backend": "http",
              "body": {
                "password": "${password}",
                "username": "${username}"
              },
              "connect_timeout": 5000,
              "enable_pipelining": 100,
              "headers": {
                "content-type": "application/json"
              },
              "mechanism": "password_based",
              "method": "post",
              "pool_size": 8,
              "request_timeout": 5000,
              "ssl": {
                "enable": false
              },
              "url": "http://127.0.0.1:18083"
            }
          },
          "password_based:mongodb": {
            "summary": "password_based authentication with MongoDB backend",
            "value": {
              "backend": "mongodb",
              "collection": "users",
              "database": "example",
              "filter": {
                "username": "${username}"
              },
              "is_superuser_field": "is_superuser",
              "mechanism": "password_based",
              "password_hash_algorithm": {
                "name": "sha256",
                "salt_position": "suffix"
              },
              "password_hash_field": "password_hash",
              "salt_field": "salt",
              "server": "127.0.0.1:27017"
            }
          },
          "password_based:redis": {
            "summary": "password_based authentication with Redis backend",
            "value": {
              "backend": "redis",
              "cmd": "HMGET ${username} password_hash salt",
              "database": 0,
              "mechanism": "password_based",
              "password_hash_algorithm": {
                "name": "sha256",
                "salt_position": "suffix"
              },
              "redis_type": "single",
              "server": "127.0.0.1:6379"
            }
          }
        },
        "name": "authentication",
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "struct",
              "name": "authn-builtin_db:authentication"
            },
            {
              "kind": "struct",
              "name": "authn-mysql:authentication"
            },
            {
              "kind": "struct",
              "name": "authn-postgresql:authentication"
            },
            {
              "kind": "struct",
              "name": "authn-mongodb:standalone"
            },
            {
              "kind": "struct",
              "name": "authn-mongodb:replica-set"
            },
            {
              "kind": "struct",
              "name": "authn-mongodb:sharded-cluster"
            },
            {
              "kind": "struct",
              "name": "authn-redis:standalone"
            },
            {
              "kind": "struct",
              "name": "authn-redis:cluster"
            },
            {
              "kind": "struct",
              "name": "authn-redis:sentinel"
            },
            {
              "kind": "struct",
              "name": "authn-http:get"
            },
            {
              "kind": "struct",
              "name": "authn-http:post"
            },
            {
              "kind": "struct",
              "name": "authn-jwt:hmac-based"
            },
            {
              "kind": "struct",
              "name": "authn-jwt:public-key"
            },
            {
              "kind": "struct",
              "name": "authn-jwt:jwks"
            },
            {
              "kind": "struct",
              "name": "authn-scram-builtin_db:authentication"
            }
          ]
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Set <code>true</code> (default) to enable client authentication on this listener. \nWhen set to <code>false</code> clients will be allowed to connect without authentication.",
        "name": "enable_authn",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "desc": "When publishing or subscribing, prefix all topics with a mountpoint string.\nThe prefixed string will be removed from the topic name when the message is delivered to the subscriber.\nThe mountpoint is a way that users can use to implement isolation of message routing between different listeners.\nFor example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`,\nthen the client actually subscribes to the topic `some_tenant/t`.\nSimilarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`,\nthe message is routed to all the clients subscribed `some_tenant/t`,\nso client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.\nVariables in mountpoint string:<br/>\n  - <code>${clientid}</code>: clientid<br/>\n  - <code>${username}</code>: username",
        "name": "mountpoint",
        "type": {
          "kind": "primitive",
          "name": "binary()"
        }
      },
      {
        "default": {
          "hocon": "[]",
          "oneliner": true
        },
        "desc": "The access control rules for this listener.\nSee: https://github.com/emqtt/esockd#allowdeny",
        "name": "access_rules",
        "raw_default": [],
        "type": {
          "elements": {
            "kind": "primitive",
            "name": "string()"
          },
          "kind": "array"
        }
      },
      {
        "desc": "DTLS socket options",
        "name": "dtls_options",
        "type": {
          "kind": "struct",
          "name": "gateway:dtls_opts"
        }
      }
    ],
    "full_name": "gateway:dtls_listener",
    "paths": [
      "gateway.coap.listeners.dtls.$name",
      "gateway.exproto.listeners.dtls.$name",
      "gateway.lwm2m.listeners.dtls.$name",
      "gateway.mqttsn.listeners.dtls.$name"
    ],
    "tags": [
      "Gateway"
    ]
  },
  {
    "desc": "Settings for the DTLS protocol.",
    "fields": [
      {
        "desc": "Trusted PEM format CA certificates bundle file.<br/>\nThe certificates in this file are used to verify the TLS peer's certificates.\nAppend new certificates to the file if new CAs are to be trusted.\nThere is no need to restart EMQX to have the updated file loaded, because\nthe system regularly checks if file has been updated (and reload).<br/>\nNOTE: invalidating (deleting) a certificate from the file will not affect\nalready established connections.",
        "name": "cacertfile",
        "type": {
          "kind": "primitive",
          "name": "binary()"
        }
      },
      {
        "desc": "PEM format certificates chain file.<br/>\nThe certificates in this file should be in reversed order of the certificate\nissue chain. That is, the host's certificate should be placed in the beginning\nof the file, followed by the immediate issuer certificate and so on.\nAlthough the root CA certificate is optional, it should be placed at the end of\nthe file if it is to be added.",
        "name": "certfile",
        "type": {
          "kind": "primitive",
          "name": "binary()"
        }
      },
      {
        "desc": "PEM format private key file.",
        "name": "keyfile",
        "type": {
          "kind": "primitive",
          "name": "binary()"
        }
      },
      {
        "default": {
          "hocon": "verify_none",
          "oneliner": true
        },
        "desc": "Enable or disable peer verification.",
        "name": "verify",
        "raw_default": "verify_none",
        "type": {
          "kind": "enum",
          "symbols": [
            "verify_peer",
            "verify_none"
          ]
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Enable TLS session reuse.",
        "name": "reuse_sessions",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "10",
          "oneliner": true
        },
        "desc": "Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path.\nSo, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly;<br/>\nif 1 the path can be PEER, Intermediate-CA, ROOT-CA;<br/>\nif 2 the path can be PEER, Intermediate-CA1, Intermediate-CA2, ROOT-CA.",
        "name": "depth",
        "raw_default": 10,
        "type": {
          "kind": "primitive",
          "name": "integer()"
        }
      },
      {
        "desc": "String containing the user's password. Only used if the private key file is password-protected.",
        "examples": [
          ""
        ],
        "name": "password",
        "type": {
          "kind": "primitive",
          "name": "string()"
        }
      },
      {
        "default": {
          "hocon": "[dtlsv1.2, dtlsv1]",
          "oneliner": true
        },
        "desc": "All TLS/DTLS versions to be supported.<br/>\nNOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.<br/>\nIn case PSK cipher suites are intended, make sure to configure\n<code>['tlsv1.2', 'tlsv1.1']</code> here.",
        "name": "versions",
        "raw_default": [
          "dtlsv1.2",
          "dtlsv1"
        ],
        "type": {
          "elements": {
            "kind": "primitive",
            "name": "atom()"
          },
          "kind": "array"
        }
      },
      {
        "default": {
          "hocon": "[]",
          "oneliner": true
        },
        "desc": "This config holds TLS cipher suite names separated by comma,\nor as an array of strings. e.g.\n<code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or\n<code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.\n<br/>\nCiphers (and their ordering) define the way in which the\nclient and server encrypts information over the network connection.\nSelecting a good cipher suite is critical for the\napplication's data security, confidentiality and performance.\n\nThe names should be in OpenSSL string format (not RFC format).\nAll default values and examples provided by EMQX config\ndocumentation are all in OpenSSL format.<br/>\n\nNOTE: Certain cipher suites are only compatible with\nspecific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')\nincompatible cipher suites will be silently dropped.\nFor instance, if only 'tlsv1.3' is given in the <code>versions</code>,\nconfiguring cipher suites for other versions will have no effect.\n<br/>\n\nNOTE: PSK ciphers are suppressed by 'tlsv1.3' version config<br/>\nIf PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.<br/>\nPSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,\nRSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,\nRSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,\nRSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code>",
        "name": "ciphers",
        "raw_default": [],
        "type": {
          "elements": {
            "kind": "primitive",
            "name": "string()"
          },
          "kind": "array"
        }
      },
      {
        "default": {
          "hocon": "\"emqx_tls_psk:lookup\"",
          "oneliner": true
        },
        "desc": "EMQX-internal callback that is used to lookup pre-shared key (PSK) identity.",
        "name": "user_lookup_fun",
        "raw_default": "emqx_tls_psk:lookup",
        "type": {
          "kind": "primitive",
          "name": "string()"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "SSL parameter renegotiation is a feature that allows a client and a server\nto renegotiate the parameters of the SSL connection on the fly.\nRFC 5746 defines a more secure way of doing this. By enabling secure renegotiation,\nyou drop support for the insecure renegotiation, prone to MitM attacks.",
        "name": "secure_renegotiate",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "\"5s\"",
          "oneliner": true
        },
        "desc": " Hibernate the SSL process after idling for amount of time reducing its memory footprint. ",
        "name": "hibernate_after",
        "raw_default": "5s",
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:duration()"
        }
      },
      {
        "desc": "Path to a file containing PEM-encoded Diffie-Hellman parameters\nto be used by the server if a cipher suite using Diffie-Hellman\nkey exchange is negotiated. If not specified, default parameters\nare used.<br/>\nNOTE: The <code>dhfile</code> option is not supported by TLS 1.3.",
        "name": "dhfile",
        "type": {
          "kind": "primitive",
          "name": "string()"
        }
      },
      {
        "default": {
          "hocon": "false",
          "oneliner": true
        },
        "desc": "Used together with {verify, verify_peer} by an TLS/DTLS server.\nIf set to true, the server fails if the client does not have a\ncertificate to send, that is, sends an empty certificate.\nIf set to false, it fails only if the client sends an invalid\ncertificate (an empty certificate is considered valid).",
        "name": "fail_if_no_peer_cert",
        "raw_default": false,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "An important security setting, it forces the cipher to be set based\n on the server-specified order instead of the client-specified order,\n hence enforcing the (usually more properly configured) security\n ordering of the server administrator.",
        "name": "honor_cipher_order",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "In protocols that support client-initiated renegotiation,\nthe cost of resources of such an operation is higher for the server than the client.\nThis can act as a vector for denial of service attacks.\nThe SSL application already takes measures to counter-act such attempts,\nbut client-initiated renegotiation can be strictly disabled by setting this option to false.\nThe default value is true. Note that disabling renegotiation can result in\nlong-lived connections becoming unusable due to limits on\nthe number of messages the underlying cipher suite can encipher.",
        "name": "client_renegotiation",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "\"15s\"",
          "oneliner": true
        },
        "desc": "Maximum time duration allowed for the handshake to complete",
        "name": "handshake_timeout",
        "raw_default": "15s",
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:duration()"
        }
      },
      {
        "default": {
          "hocon": "false",
          "oneliner": true
        },
        "desc": "Memory usage tuning. If enabled, will immediately perform a garbage collection after the TLS/SSL handshake.",
        "name": "gc_after_handshake",
        "raw_default": false,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      }
    ],
    "full_name": "gateway:dtls_opts",
    "paths": [
      "gateway.coap.listeners.dtls.$name.dtls_options",
      "gateway.exproto.listeners.dtls.$name.dtls_options",
      "gateway.lwm2m.listeners.dtls.$name.dtls_options",
      "gateway.mqttsn.listeners.dtls.$name.dtls_options"
    ],
    "tags": [
      "Gateway"
    ]
  },
  {
    "desc": "Settings for EMQX extension protocol (exproto).",
    "fields": [
      {
        "desc": "Configurations for starting the <code>ConnectionAdapter</code> service",
        "name": "server",
        "type": {
          "kind": "struct",
          "name": "gateway:exproto_grpc_server"
        }
      },
      {
        "desc": "Configurations for request to <code>ConnectionHandler</code> service",
        "name": "handler",
        "type": {
          "kind": "struct",
          "name": "gateway:exproto_grpc_handler"
        }
      },
      {
        "default": {
          "hocon": "\"\"",
          "oneliner": true
        },
        "desc": "",
        "name": "mountpoint",
        "raw_default": "",
        "type": {
          "kind": "primitive",
          "name": "binary()"
        }
      },
      {
        "desc": "Settings for the listeners.",
        "name": "listeners",
        "type": {
          "kind": "struct",
          "name": "gateway:tcp_udp_listeners"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Whether to enable this gateway",
        "name": "enable",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Whether to enable client process statistic",
        "name": "enable_stats",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "\"30s\"",
          "oneliner": true
        },
        "desc": "The idle time of the client connection process. It has two purposes:\n  1. A newly created client process that does not receive any client requests after that time will be closed directly.\n  2. A running client process that does not receive any client requests after this time will go into hibernation to save resources.",
        "name": "idle_timeout",
        "raw_default": "30s",
        "type": {
          "kind": "primitive",
          "name": "emqx_gateway_schema:duration()"
        }
      },
      {
        "desc": "ClientInfo override.",
        "name": "clientinfo_override",
        "type": {
          "kind": "struct",
          "name": "gateway:clientinfo_override"
        }
      },
      {
        "desc": "Default authentication configs for all the gateway listeners. For per-listener overrides see <code>authentication</code>\n in listener configs",
        "examples": {
          "jwt": {
            "summary": "JWT authentication",
            "value": {
              "algorithm": "hmac-based",
              "mechanism": "jwt",
              "secret": "mysecret",
              "secret_base64_encoded": false,
              "use_jwks": false,
              "verify_claims": {
                "username": "${username}"
              }
            }
          },
          "password_based:built_in_database": {
            "summary": "Built-in password_based authentication",
            "value": {
              "backend": "built_in_database",
              "mechanism": "password_based",
              "password_hash_algorithm": {
                "name": "sha256",
                "salt_position": "suffix"
              },
              "user_id_type": "username"
            }
          },
          "password_based:http": {
            "summary": "password_based authentication through external HTTP API",
            "value": {
              "backend": "http",
              "body": {
                "password": "${password}",
                "username": "${username}"
              },
              "connect_timeout": 5000,
              "enable_pipelining": 100,
              "headers": {
                "content-type": "application/json"
              },
              "mechanism": "password_based",
              "method": "post",
              "pool_size": 8,
              "request_timeout": 5000,
              "ssl": {
                "enable": false
              },
              "url": "http://127.0.0.1:18083"
            }
          },
          "password_based:mongodb": {
            "summary": "password_based authentication with MongoDB backend",
            "value": {
              "backend": "mongodb",
              "collection": "users",
              "database": "example",
              "filter": {
                "username": "${username}"
              },
              "is_superuser_field": "is_superuser",
              "mechanism": "password_based",
              "password_hash_algorithm": {
                "name": "sha256",
                "salt_position": "suffix"
              },
              "password_hash_field": "password_hash",
              "salt_field": "salt",
              "server": "127.0.0.1:27017"
            }
          },
          "password_based:redis": {
            "summary": "password_based authentication with Redis backend",
            "value": {
              "backend": "redis",
              "cmd": "HMGET ${username} password_hash salt",
              "database": 0,
              "mechanism": "password_based",
              "password_hash_algorithm": {
                "name": "sha256",
                "salt_position": "suffix"
              },
              "redis_type": "single",
              "server": "127.0.0.1:6379"
            }
          }
        },
        "name": "authentication",
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "struct",
              "name": "authn-builtin_db:authentication"
            },
            {
              "kind": "struct",
              "name": "authn-mysql:authentication"
            },
            {
              "kind": "struct",
              "name": "authn-postgresql:authentication"
            },
            {
              "kind": "struct",
              "name": "authn-mongodb:standalone"
            },
            {
              "kind": "struct",
              "name": "authn-mongodb:replica-set"
            },
            {
              "kind": "struct",
              "name": "authn-mongodb:sharded-cluster"
            },
            {
              "kind": "struct",
              "name": "authn-redis:standalone"
            },
            {
              "kind": "struct",
              "name": "authn-redis:cluster"
            },
            {
              "kind": "struct",
              "name": "authn-redis:sentinel"
            },
            {
              "kind": "struct",
              "name": "authn-http:get"
            },
            {
              "kind": "struct",
              "name": "authn-http:post"
            },
            {
              "kind": "struct",
              "name": "authn-jwt:hmac-based"
            },
            {
              "kind": "struct",
              "name": "authn-jwt:public-key"
            },
            {
              "kind": "struct",
              "name": "authn-jwt:jwks"
            },
            {
              "kind": "struct",
              "name": "authn-scram-builtin_db:authentication"
            }
          ]
        }
      }
    ],
    "full_name": "gateway:exproto",
    "paths": [
      "gateway.exproto"
    ],
    "tags": [
      "Gateway"
    ]
  },
  {
    "desc": "Settings for the exproto gRPC connection handler.",
    "fields": [
      {
        "desc": "gRPC server address.",
        "name": "address",
        "type": {
          "kind": "primitive",
          "name": "binary()"
        }
      },
      {
        "desc": "SSL configuration for the gRPC client.",
        "name": "ssl_options",
        "type": {
          "kind": "struct",
          "name": "broker:ssl_client_opts"
        }
      }
    ],
    "full_name": "gateway:exproto_grpc_handler",
    "paths": [
      "gateway.exproto.handler"
    ],
    "tags": [
      "Gateway"
    ]
  },
  {
    "desc": "Settings for the exproto gRPC server.",
    "fields": [
      {
        "desc": "Listening address and port for the gRPC server.",
        "name": "bind",
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "primitive",
              "name": "emqx_gateway_schema:ip_port()"
            },
            {
              "kind": "primitive",
              "name": "integer()"
            }
          ]
        }
      },
      {
        "desc": "SSL configuration for the gRPC server.",
        "name": "ssl_options",
        "type": {
          "kind": "struct",
          "name": "gateway:ssl_server_opts"
        }
      }
    ],
    "full_name": "gateway:exproto_grpc_server",
    "paths": [
      "gateway.exproto.server"
    ],
    "tags": [
      "Gateway"
    ]
  },
  {
    "desc": "EMQX Gateway configuration root.",
    "fields": [
      {
        "desc": "The Stomp Gateway configuration.\nThis gateway supports v1.2/1.1/1.0",
        "name": "stomp",
        "type": {
          "kind": "struct",
          "name": "gateway:stomp"
        }
      },
      {
        "desc": "The MQTT-SN Gateway configuration.\nThis gateway only supports the v1.2 protocol",
        "name": "mqttsn",
        "type": {
          "kind": "struct",
          "name": "gateway:mqttsn"
        }
      },
      {
        "desc": "The CoAP Gateway configuration.\nThis gateway is implemented based on RFC-7252 and https://core-wg.github.io/coap-pubsub/draft-ietf-core-pubsub.html",
        "name": "coap",
        "type": {
          "kind": "struct",
          "name": "gateway:coap"
        }
      },
      {
        "desc": "The LwM2M Gateway configuration. This gateway only supports the v1.0.1 protocol.",
        "name": "lwm2m",
        "type": {
          "kind": "struct",
          "name": "gateway:lwm2m"
        }
      },
      {
        "desc": "The Extension Protocol configuration",
        "name": "exproto",
        "type": {
          "kind": "struct",
          "name": "gateway:exproto"
        }
      }
    ],
    "full_name": "gateway",
    "paths": [
      "gateway"
    ],
    "tags": [
      "Gateway"
    ]
  },
  {
    "desc": "The LwM2M protocol gateway.",
    "fields": [
      {
        "desc": "The Directory for LwM2M Resource definition.",
        "examples": [
          "/etc/emqx/lwm2m_xml"
        ],
        "name": "xml_dir",
        "type": {
          "kind": "primitive",
          "name": "binary()"
        }
      },
      {
        "default": {
          "hocon": "\"15s\"",
          "oneliner": true
        },
        "desc": "Minimum value of lifetime allowed to be set by the LwM2M client.",
        "name": "lifetime_min",
        "raw_default": "15s",
        "type": {
          "kind": "primitive",
          "name": "emqx_gateway_schema:duration()"
        }
      },
      {
        "default": {
          "hocon": "\"86400s\"",
          "oneliner": true
        },
        "desc": "Maximum value of lifetime allowed to be set by the LwM2M client.",
        "name": "lifetime_max",
        "raw_default": "86400s",
        "type": {
          "kind": "primitive",
          "name": "emqx_gateway_schema:duration()"
        }
      },
      {
        "default": {
          "hocon": "\"22s\"",
          "oneliner": true
        },
        "desc": "The value of the time window during which the network link is considered valid by the LwM2M Gateway in QMode mode.\nFor example, after receiving an update message from a client, any messages within this time window are sent directly to the LwM2M client, and all messages beyond this time window are temporarily stored in memory.",
        "name": "qmode_time_window",
        "raw_default": "22s",
        "type": {
          "kind": "primitive",
          "name": "emqx_gateway_schema:duration_s()"
        }
      },
      {
        "default": {
          "hocon": "false",
          "oneliner": true
        },
        "desc": "Automatically observe the object list of REGISTER packet.",
        "name": "auto_observe",
        "raw_default": false,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "contains_object_list",
          "oneliner": true
        },
        "desc": "Policy for publishing UPDATE event message.<br/>\n  - always: send update events as long as the UPDATE request is received.<br/>\n  - contains_object_list: send update events only if the UPDATE request carries any Object List",
        "name": "update_msg_publish_condition",
        "raw_default": "contains_object_list",
        "type": {
          "kind": "enum",
          "symbols": [
            "always",
            "contains_object_list"
          ]
        }
      },
      {
        "desc": "Topic configuration for LwM2M's gateway publishing and subscription.",
        "name": "translators",
        "type": {
          "kind": "struct",
          "name": "gateway:lwm2m_translators"
        }
      },
      {
        "default": {
          "hocon": "\"lwm2m/${endpoint_name}/\"",
          "oneliner": true
        },
        "desc": "",
        "name": "mountpoint",
        "raw_default": "lwm2m/${endpoint_name}/",
        "type": {
          "kind": "primitive",
          "name": "binary()"
        }
      },
      {
        "desc": "Settings for the UDP listeners.",
        "name": "listeners",
        "type": {
          "kind": "struct",
          "name": "gateway:udp_listeners"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Whether to enable this gateway",
        "name": "enable",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Whether to enable client process statistic",
        "name": "enable_stats",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "\"30s\"",
          "oneliner": true
        },
        "desc": "The idle time of the client connection process. It has two purposes:\n  1. A newly created client process that does not receive any client requests after that time will be closed directly.\n  2. A running client process that does not receive any client requests after this time will go into hibernation to save resources.",
        "name": "idle_timeout",
        "raw_default": "30s",
        "type": {
          "kind": "primitive",
          "name": "emqx_gateway_schema:duration()"
        }
      },
      {
        "desc": "ClientInfo override.",
        "name": "clientinfo_override",
        "type": {
          "kind": "struct",
          "name": "gateway:clientinfo_override"
        }
      },
      {
        "desc": "Default authentication configs for all the gateway listeners. For per-listener overrides see <code>authentication</code>\n in listener configs",
        "examples": {
          "jwt": {
            "summary": "JWT authentication",
            "value": {
              "algorithm": "hmac-based",
              "mechanism": "jwt",
              "secret": "mysecret",
              "secret_base64_encoded": false,
              "use_jwks": false,
              "verify_claims": {
                "username": "${username}"
              }
            }
          },
          "password_based:built_in_database": {
            "summary": "Built-in password_based authentication",
            "value": {
              "backend": "built_in_database",
              "mechanism": "password_based",
              "password_hash_algorithm": {
                "name": "sha256",
                "salt_position": "suffix"
              },
              "user_id_type": "username"
            }
          },
          "password_based:http": {
            "summary": "password_based authentication through external HTTP API",
            "value": {
              "backend": "http",
              "body": {
                "password": "${password}",
                "username": "${username}"
              },
              "connect_timeout": 5000,
              "enable_pipelining": 100,
              "headers": {
                "content-type": "application/json"
              },
              "mechanism": "password_based",
              "method": "post",
              "pool_size": 8,
              "request_timeout": 5000,
              "ssl": {
                "enable": false
              },
              "url": "http://127.0.0.1:18083"
            }
          },
          "password_based:mongodb": {
            "summary": "password_based authentication with MongoDB backend",
            "value": {
              "backend": "mongodb",
              "collection": "users",
              "database": "example",
              "filter": {
                "username": "${username}"
              },
              "is_superuser_field": "is_superuser",
              "mechanism": "password_based",
              "password_hash_algorithm": {
                "name": "sha256",
                "salt_position": "suffix"
              },
              "password_hash_field": "password_hash",
              "salt_field": "salt",
              "server": "127.0.0.1:27017"
            }
          },
          "password_based:redis": {
            "summary": "password_based authentication with Redis backend",
            "value": {
              "backend": "redis",
              "cmd": "HMGET ${username} password_hash salt",
              "database": 0,
              "mechanism": "password_based",
              "password_hash_algorithm": {
                "name": "sha256",
                "salt_position": "suffix"
              },
              "redis_type": "single",
              "server": "127.0.0.1:6379"
            }
          }
        },
        "name": "authentication",
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "struct",
              "name": "authn-builtin_db:authentication"
            },
            {
              "kind": "struct",
              "name": "authn-mysql:authentication"
            },
            {
              "kind": "struct",
              "name": "authn-postgresql:authentication"
            },
            {
              "kind": "struct",
              "name": "authn-mongodb:standalone"
            },
            {
              "kind": "struct",
              "name": "authn-mongodb:replica-set"
            },
            {
              "kind": "struct",
              "name": "authn-mongodb:sharded-cluster"
            },
            {
              "kind": "struct",
              "name": "authn-redis:standalone"
            },
            {
              "kind": "struct",
              "name": "authn-redis:cluster"
            },
            {
              "kind": "struct",
              "name": "authn-redis:sentinel"
            },
            {
              "kind": "struct",
              "name": "authn-http:get"
            },
            {
              "kind": "struct",
              "name": "authn-http:post"
            },
            {
              "kind": "struct",
              "name": "authn-jwt:hmac-based"
            },
            {
              "kind": "struct",
              "name": "authn-jwt:public-key"
            },
            {
              "kind": "struct",
              "name": "authn-jwt:jwks"
            },
            {
              "kind": "struct",
              "name": "authn-scram-builtin_db:authentication"
            }
          ]
        }
      }
    ],
    "full_name": "gateway:lwm2m",
    "paths": [
      "gateway.lwm2m"
    ],
    "tags": [
      "Gateway"
    ]
  },
  {
    "desc": "MQTT topics that correspond to LwM2M events.",
    "fields": [
      {
        "desc": "The topic for receiving downstream commands.\nFor each new LwM2M client that succeeds in going online, the gateway creates a subscription relationship to receive downstream commands and send it to the LwM2M client",
        "name": "command",
        "type": {
          "kind": "struct",
          "name": "gateway:translator"
        }
      },
      {
        "desc": "The topic for gateway to publish the acknowledge events from LwM2M client",
        "name": "response",
        "type": {
          "kind": "struct",
          "name": "gateway:translator"
        }
      },
      {
        "desc": "The topic for gateway to publish the notify events from LwM2M client.\nAfter succeed observe a resource of LwM2M client, Gateway will send the notify events via this topic, if the client reports any resource changes",
        "name": "notify",
        "type": {
          "kind": "struct",
          "name": "gateway:translator"
        }
      },
      {
        "desc": "The topic for gateway to publish the register events from LwM2M client.",
        "name": "register",
        "type": {
          "kind": "struct",
          "name": "gateway:translator"
        }
      },
      {
        "desc": "The topic for gateway to publish the update events from LwM2M client",
        "name": "update",
        "type": {
          "kind": "struct",
          "name": "gateway:translator"
        }
      }
    ],
    "full_name": "gateway:lwm2m_translators",
    "paths": [
      "gateway.lwm2m.translators"
    ],
    "tags": [
      "Gateway"
    ]
  },
  {
    "desc": "The MQTT-SN (MQTT for Sensor Networks) protocol gateway.",
    "fields": [
      {
        "default": {
          "hocon": "1",
          "oneliner": true
        },
        "desc": "MQTT-SN Gateway ID.\nWhen the <code>broadcast</code> option is enabled, the gateway will broadcast ADVERTISE message with this value",
        "name": "gateway_id",
        "raw_default": 1,
        "type": {
          "kind": "primitive",
          "name": "integer()"
        }
      },
      {
        "default": {
          "hocon": "false",
          "oneliner": true
        },
        "desc": "Whether to periodically broadcast ADVERTISE messages",
        "name": "broadcast",
        "raw_default": false,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Allows connectionless clients to publish messages with a Qos of -1.\nThis feature is defined for very simple client implementations which do not support any other features except this one. There is no connection setup nor tear down, no registration nor subscription. The client just sends its 'PUBLISH' messages to a GW",
        "name": "enable_qos3",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "false",
          "oneliner": true
        },
        "desc": "Whether to initiate all subscribed topic name registration messages to the client after the Session has been taken over by a new channel",
        "name": "subs_resume",
        "raw_default": false,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "[]",
          "oneliner": true
        },
        "desc": "The pre-defined topic IDs and topic names.\nA 'pre-defined' topic ID is a topic ID whose mapping to a topic name is known in advance by both the client's application and the gateway",
        "name": "predefined",
        "raw_default": [],
        "type": {
          "elements": {
            "kind": "struct",
            "name": "gateway:mqttsn_predefined"
          },
          "kind": "array"
        }
      },
      {
        "default": {
          "hocon": "\"\"",
          "oneliner": true
        },
        "desc": "",
        "name": "mountpoint",
        "raw_default": "",
        "type": {
          "kind": "primitive",
          "name": "binary()"
        }
      },
      {
        "desc": "Settings for the UDP listeners.",
        "name": "listeners",
        "type": {
          "kind": "struct",
          "name": "gateway:udp_listeners"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Whether to enable this gateway",
        "name": "enable",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Whether to enable client process statistic",
        "name": "enable_stats",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "\"30s\"",
          "oneliner": true
        },
        "desc": "The idle time of the client connection process. It has two purposes:\n  1. A newly created client process that does not receive any client requests after that time will be closed directly.\n  2. A running client process that does not receive any client requests after this time will go into hibernation to save resources.",
        "name": "idle_timeout",
        "raw_default": "30s",
        "type": {
          "kind": "primitive",
          "name": "emqx_gateway_schema:duration()"
        }
      },
      {
        "desc": "ClientInfo override.",
        "name": "clientinfo_override",
        "type": {
          "kind": "struct",
          "name": "gateway:clientinfo_override"
        }
      },
      {
        "desc": "Default authentication configs for all the gateway listeners. For per-listener overrides see <code>authentication</code>\n in listener configs",
        "examples": {
          "jwt": {
            "summary": "JWT authentication",
            "value": {
              "algorithm": "hmac-based",
              "mechanism": "jwt",
              "secret": "mysecret",
              "secret_base64_encoded": false,
              "use_jwks": false,
              "verify_claims": {
                "username": "${username}"
              }
            }
          },
          "password_based:built_in_database": {
            "summary": "Built-in password_based authentication",
            "value": {
              "backend": "built_in_database",
              "mechanism": "password_based",
              "password_hash_algorithm": {
                "name": "sha256",
                "salt_position": "suffix"
              },
              "user_id_type": "username"
            }
          },
          "password_based:http": {
            "summary": "password_based authentication through external HTTP API",
            "value": {
              "backend": "http",
              "body": {
                "password": "${password}",
                "username": "${username}"
              },
              "connect_timeout": 5000,
              "enable_pipelining": 100,
              "headers": {
                "content-type": "application/json"
              },
              "mechanism": "password_based",
              "method": "post",
              "pool_size": 8,
              "request_timeout": 5000,
              "ssl": {
                "enable": false
              },
              "url": "http://127.0.0.1:18083"
            }
          },
          "password_based:mongodb": {
            "summary": "password_based authentication with MongoDB backend",
            "value": {
              "backend": "mongodb",
              "collection": "users",
              "database": "example",
              "filter": {
                "username": "${username}"
              },
              "is_superuser_field": "is_superuser",
              "mechanism": "password_based",
              "password_hash_algorithm": {
                "name": "sha256",
                "salt_position": "suffix"
              },
              "password_hash_field": "password_hash",
              "salt_field": "salt",
              "server": "127.0.0.1:27017"
            }
          },
          "password_based:redis": {
            "summary": "password_based authentication with Redis backend",
            "value": {
              "backend": "redis",
              "cmd": "HMGET ${username} password_hash salt",
              "database": 0,
              "mechanism": "password_based",
              "password_hash_algorithm": {
                "name": "sha256",
                "salt_position": "suffix"
              },
              "redis_type": "single",
              "server": "127.0.0.1:6379"
            }
          }
        },
        "name": "authentication",
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "struct",
              "name": "authn-builtin_db:authentication"
            },
            {
              "kind": "struct",
              "name": "authn-mysql:authentication"
            },
            {
              "kind": "struct",
              "name": "authn-postgresql:authentication"
            },
            {
              "kind": "struct",
              "name": "authn-mongodb:standalone"
            },
            {
              "kind": "struct",
              "name": "authn-mongodb:replica-set"
            },
            {
              "kind": "struct",
              "name": "authn-mongodb:sharded-cluster"
            },
            {
              "kind": "struct",
              "name": "authn-redis:standalone"
            },
            {
              "kind": "struct",
              "name": "authn-redis:cluster"
            },
            {
              "kind": "struct",
              "name": "authn-redis:sentinel"
            },
            {
              "kind": "struct",
              "name": "authn-http:get"
            },
            {
              "kind": "struct",
              "name": "authn-http:post"
            },
            {
              "kind": "struct",
              "name": "authn-jwt:hmac-based"
            },
            {
              "kind": "struct",
              "name": "authn-jwt:public-key"
            },
            {
              "kind": "struct",
              "name": "authn-jwt:jwks"
            },
            {
              "kind": "struct",
              "name": "authn-scram-builtin_db:authentication"
            }
          ]
        }
      }
    ],
    "full_name": "gateway:mqttsn",
    "paths": [
      "gateway.mqttsn"
    ],
    "tags": [
      "Gateway"
    ]
  },
  {
    "desc": "The pre-defined topic name corresponding to the pre-defined topic\nID of N.\n\nNote: the pre-defined topic ID of 0 is reserved.",
    "fields": [
      {
        "desc": "Topic ID. Range: 1-65535",
        "name": "id",
        "type": {
          "kind": "primitive",
          "name": "integer()"
        }
      },
      {
        "desc": "Topic Name",
        "name": "topic",
        "type": {
          "kind": "primitive",
          "name": "binary()"
        }
      }
    ],
    "full_name": "gateway:mqttsn_predefined",
    "paths": [
      "gateway.mqttsn.predefined.$INDEX"
    ],
    "tags": [
      "Gateway"
    ]
  },
  {
    "desc": "Settings for the SSL listener.",
    "fields": [
      {
        "default": {
          "hocon": "16",
          "oneliner": true
        },
        "desc": "Size of the acceptor pool.",
        "name": "acceptors",
        "raw_default": 16,
        "type": {
          "kind": "primitive",
          "name": "integer()"
        }
      },
      {
        "desc": "Setting the TCP socket options.",
        "name": "tcp_options",
        "type": {
          "kind": "struct",
          "name": "broker:tcp_opts"
        }
      },
      {
        "default": {
          "hocon": "false",
          "oneliner": true
        },
        "desc": "Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.\nSee: https://www.haproxy.com/blog/haproxy/proxy-protocol/",
        "name": "proxy_protocol",
        "raw_default": false,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "\"15s\"",
          "oneliner": true
        },
        "desc": "Timeout for proxy protocol.\nEMQX will close the TCP connection if proxy protocol packet is not received within the timeout.",
        "name": "proxy_protocol_timeout",
        "raw_default": "15s",
        "type": {
          "kind": "primitive",
          "name": "emqx_gateway_schema:duration()"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Enable the listener.",
        "name": "enable",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "desc": "The IP address and port that the listener will bind.",
        "name": "bind",
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "primitive",
              "name": "emqx_gateway_schema:ip_port()"
            },
            {
              "kind": "primitive",
              "name": "integer()"
            }
          ]
        }
      },
      {
        "default": {
          "hocon": "1024",
          "oneliner": true
        },
        "desc": "Maximum number of concurrent connections.",
        "name": "max_connections",
        "raw_default": 1024,
        "type": {
          "kind": "primitive",
          "name": "integer()"
        }
      },
      {
        "default": {
          "hocon": "1000",
          "oneliner": true
        },
        "desc": "Maximum connections per second.",
        "name": "max_conn_rate",
        "raw_default": 1000,
        "type": {
          "kind": "primitive",
          "name": "integer()"
        }
      },
      {
        "desc": "Default authentication configs for all the gateway listeners. For per-listener overrides see <code>authentication</code>\n in listener configs",
        "examples": {
          "jwt": {
            "summary": "JWT authentication",
            "value": {
              "algorithm": "hmac-based",
              "mechanism": "jwt",
              "secret": "mysecret",
              "secret_base64_encoded": false,
              "use_jwks": false,
              "verify_claims": {
                "username": "${username}"
              }
            }
          },
          "password_based:built_in_database": {
            "summary": "Built-in password_based authentication",
            "value": {
              "backend": "built_in_database",
              "mechanism": "password_based",
              "password_hash_algorithm": {
                "name": "sha256",
                "salt_position": "suffix"
              },
              "user_id_type": "username"
            }
          },
          "password_based:http": {
            "summary": "password_based authentication through external HTTP API",
            "value": {
              "backend": "http",
              "body": {
                "password": "${password}",
                "username": "${username}"
              },
              "connect_timeout": 5000,
              "enable_pipelining": 100,
              "headers": {
                "content-type": "application/json"
              },
              "mechanism": "password_based",
              "method": "post",
              "pool_size": 8,
              "request_timeout": 5000,
              "ssl": {
                "enable": false
              },
              "url": "http://127.0.0.1:18083"
            }
          },
          "password_based:mongodb": {
            "summary": "password_based authentication with MongoDB backend",
            "value": {
              "backend": "mongodb",
              "collection": "users",
              "database": "example",
              "filter": {
                "username": "${username}"
              },
              "is_superuser_field": "is_superuser",
              "mechanism": "password_based",
              "password_hash_algorithm": {
                "name": "sha256",
                "salt_position": "suffix"
              },
              "password_hash_field": "password_hash",
              "salt_field": "salt",
              "server": "127.0.0.1:27017"
            }
          },
          "password_based:redis": {
            "summary": "password_based authentication with Redis backend",
            "value": {
              "backend": "redis",
              "cmd": "HMGET ${username} password_hash salt",
              "database": 0,
              "mechanism": "password_based",
              "password_hash_algorithm": {
                "name": "sha256",
                "salt_position": "suffix"
              },
              "redis_type": "single",
              "server": "127.0.0.1:6379"
            }
          }
        },
        "name": "authentication",
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "struct",
              "name": "authn-builtin_db:authentication"
            },
            {
              "kind": "struct",
              "name": "authn-mysql:authentication"
            },
            {
              "kind": "struct",
              "name": "authn-postgresql:authentication"
            },
            {
              "kind": "struct",
              "name": "authn-mongodb:standalone"
            },
            {
              "kind": "struct",
              "name": "authn-mongodb:replica-set"
            },
            {
              "kind": "struct",
              "name": "authn-mongodb:sharded-cluster"
            },
            {
              "kind": "struct",
              "name": "authn-redis:standalone"
            },
            {
              "kind": "struct",
              "name": "authn-redis:cluster"
            },
            {
              "kind": "struct",
              "name": "authn-redis:sentinel"
            },
            {
              "kind": "struct",
              "name": "authn-http:get"
            },
            {
              "kind": "struct",
              "name": "authn-http:post"
            },
            {
              "kind": "struct",
              "name": "authn-jwt:hmac-based"
            },
            {
              "kind": "struct",
              "name": "authn-jwt:public-key"
            },
            {
              "kind": "struct",
              "name": "authn-jwt:jwks"
            },
            {
              "kind": "struct",
              "name": "authn-scram-builtin_db:authentication"
            }
          ]
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Set <code>true</code> (default) to enable client authentication on this listener. \nWhen set to <code>false</code> clients will be allowed to connect without authentication.",
        "name": "enable_authn",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "desc": "When publishing or subscribing, prefix all topics with a mountpoint string.\nThe prefixed string will be removed from the topic name when the message is delivered to the subscriber.\nThe mountpoint is a way that users can use to implement isolation of message routing between different listeners.\nFor example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`,\nthen the client actually subscribes to the topic `some_tenant/t`.\nSimilarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`,\nthe message is routed to all the clients subscribed `some_tenant/t`,\nso client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.\nVariables in mountpoint string:<br/>\n  - <code>${clientid}</code>: clientid<br/>\n  - <code>${username}</code>: username",
        "name": "mountpoint",
        "type": {
          "kind": "primitive",
          "name": "binary()"
        }
      },
      {
        "default": {
          "hocon": "[]",
          "oneliner": true
        },
        "desc": "The access control rules for this listener.\nSee: https://github.com/emqtt/esockd#allowdeny",
        "name": "access_rules",
        "raw_default": [],
        "type": {
          "elements": {
            "kind": "primitive",
            "name": "string()"
          },
          "kind": "array"
        }
      },
      {
        "desc": "SSL Socket options.",
        "name": "ssl_options",
        "type": {
          "kind": "struct",
          "name": "broker:listener_ssl_opts"
        }
      }
    ],
    "full_name": "gateway:ssl_listener",
    "paths": [
      "gateway.exproto.listeners.ssl.$name",
      "gateway.stomp.listeners.ssl.$name"
    ],
    "tags": [
      "Gateway"
    ]
  },
  {
    "desc": "SSL configuration for the server.",
    "fields": [
      {
        "desc": "Trusted PEM format CA certificates bundle file.<br/>\nThe certificates in this file are used to verify the TLS peer's certificates.\nAppend new certificates to the file if new CAs are to be trusted.\nThere is no need to restart EMQX to have the updated file loaded, because\nthe system regularly checks if file has been updated (and reload).<br/>\nNOTE: invalidating (deleting) a certificate from the file will not affect\nalready established connections.",
        "name": "cacertfile",
        "type": {
          "kind": "primitive",
          "name": "binary()"
        }
      },
      {
        "desc": "PEM format certificates chain file.<br/>\nThe certificates in this file should be in reversed order of the certificate\nissue chain. That is, the host's certificate should be placed in the beginning\nof the file, followed by the immediate issuer certificate and so on.\nAlthough the root CA certificate is optional, it should be placed at the end of\nthe file if it is to be added.",
        "name": "certfile",
        "type": {
          "kind": "primitive",
          "name": "binary()"
        }
      },
      {
        "desc": "PEM format private key file.",
        "name": "keyfile",
        "type": {
          "kind": "primitive",
          "name": "binary()"
        }
      },
      {
        "default": {
          "hocon": "verify_none",
          "oneliner": true
        },
        "desc": "Enable or disable peer verification.",
        "name": "verify",
        "raw_default": "verify_none",
        "type": {
          "kind": "enum",
          "symbols": [
            "verify_peer",
            "verify_none"
          ]
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Enable TLS session reuse.",
        "name": "reuse_sessions",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "10",
          "oneliner": true
        },
        "desc": "Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path.\nSo, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly;<br/>\nif 1 the path can be PEER, Intermediate-CA, ROOT-CA;<br/>\nif 2 the path can be PEER, Intermediate-CA1, Intermediate-CA2, ROOT-CA.",
        "name": "depth",
        "raw_default": 10,
        "type": {
          "kind": "primitive",
          "name": "integer()"
        }
      },
      {
        "desc": "String containing the user's password. Only used if the private key file is password-protected.",
        "examples": [
          ""
        ],
        "name": "password",
        "type": {
          "kind": "primitive",
          "name": "string()"
        }
      },
      {
        "default": {
          "hocon": "[tlsv1.3, tlsv1.2, tlsv1.1, tlsv1]",
          "oneliner": true
        },
        "desc": "All TLS/DTLS versions to be supported.<br/>\nNOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.<br/>\nIn case PSK cipher suites are intended, make sure to configure\n<code>['tlsv1.2', 'tlsv1.1']</code> here.",
        "name": "versions",
        "raw_default": [
          "tlsv1.3",
          "tlsv1.2",
          "tlsv1.1",
          "tlsv1"
        ],
        "type": {
          "elements": {
            "kind": "primitive",
            "name": "atom()"
          },
          "kind": "array"
        }
      },
      {
        "default": {
          "hocon": "[]",
          "oneliner": true
        },
        "desc": "This config holds TLS cipher suite names separated by comma,\nor as an array of strings. e.g.\n<code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or\n<code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.\n<br/>\nCiphers (and their ordering) define the way in which the\nclient and server encrypts information over the network connection.\nSelecting a good cipher suite is critical for the\napplication's data security, confidentiality and performance.\n\nThe names should be in OpenSSL string format (not RFC format).\nAll default values and examples provided by EMQX config\ndocumentation are all in OpenSSL format.<br/>\n\nNOTE: Certain cipher suites are only compatible with\nspecific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')\nincompatible cipher suites will be silently dropped.\nFor instance, if only 'tlsv1.3' is given in the <code>versions</code>,\nconfiguring cipher suites for other versions will have no effect.\n<br/>\n\nNOTE: PSK ciphers are suppressed by 'tlsv1.3' version config<br/>\nIf PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.<br/>\nPSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,\nRSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,\nRSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,\nRSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code>",
        "name": "ciphers",
        "raw_default": [],
        "type": {
          "elements": {
            "kind": "primitive",
            "name": "string()"
          },
          "kind": "array"
        }
      },
      {
        "default": {
          "hocon": "\"emqx_tls_psk:lookup\"",
          "oneliner": true
        },
        "desc": "EMQX-internal callback that is used to lookup pre-shared key (PSK) identity.",
        "name": "user_lookup_fun",
        "raw_default": "emqx_tls_psk:lookup",
        "type": {
          "kind": "primitive",
          "name": "string()"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "SSL parameter renegotiation is a feature that allows a client and a server\nto renegotiate the parameters of the SSL connection on the fly.\nRFC 5746 defines a more secure way of doing this. By enabling secure renegotiation,\nyou drop support for the insecure renegotiation, prone to MitM attacks.",
        "name": "secure_renegotiate",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "\"5s\"",
          "oneliner": true
        },
        "desc": " Hibernate the SSL process after idling for amount of time reducing its memory footprint. ",
        "name": "hibernate_after",
        "raw_default": "5s",
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:duration()"
        }
      },
      {
        "desc": "Path to a file containing PEM-encoded Diffie-Hellman parameters\nto be used by the server if a cipher suite using Diffie-Hellman\nkey exchange is negotiated. If not specified, default parameters\nare used.<br/>\nNOTE: The <code>dhfile</code> option is not supported by TLS 1.3.",
        "name": "dhfile",
        "type": {
          "kind": "primitive",
          "name": "string()"
        }
      },
      {
        "default": {
          "hocon": "false",
          "oneliner": true
        },
        "desc": "Used together with {verify, verify_peer} by an TLS/DTLS server.\nIf set to true, the server fails if the client does not have a\ncertificate to send, that is, sends an empty certificate.\nIf set to false, it fails only if the client sends an invalid\ncertificate (an empty certificate is considered valid).",
        "name": "fail_if_no_peer_cert",
        "raw_default": false,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "An important security setting, it forces the cipher to be set based\n on the server-specified order instead of the client-specified order,\n hence enforcing the (usually more properly configured) security\n ordering of the server administrator.",
        "name": "honor_cipher_order",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "In protocols that support client-initiated renegotiation,\nthe cost of resources of such an operation is higher for the server than the client.\nThis can act as a vector for denial of service attacks.\nThe SSL application already takes measures to counter-act such attempts,\nbut client-initiated renegotiation can be strictly disabled by setting this option to false.\nThe default value is true. Note that disabling renegotiation can result in\nlong-lived connections becoming unusable due to limits on\nthe number of messages the underlying cipher suite can encipher.",
        "name": "client_renegotiation",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "\"15s\"",
          "oneliner": true
        },
        "desc": "Maximum time duration allowed for the handshake to complete",
        "name": "handshake_timeout",
        "raw_default": "15s",
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:duration()"
        }
      }
    ],
    "full_name": "gateway:ssl_server_opts",
    "paths": [
      "gateway.exproto.server.ssl_options"
    ],
    "tags": [
      "Gateway"
    ]
  },
  {
    "desc": "The STOMP protocol gateway provides EMQX with the ability to access STOMP\n(Simple (or Streaming) Text Orientated Messaging Protocol) protocol.",
    "fields": [
      {
        "name": "frame",
        "type": {
          "kind": "struct",
          "name": "gateway:stomp_frame"
        }
      },
      {
        "default": {
          "hocon": "\"\"",
          "oneliner": true
        },
        "desc": "",
        "name": "mountpoint",
        "raw_default": "",
        "type": {
          "kind": "primitive",
          "name": "binary()"
        }
      },
      {
        "desc": "Settings for the TCP listeners.",
        "name": "listeners",
        "type": {
          "kind": "struct",
          "name": "gateway:tcp_listeners"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Whether to enable this gateway",
        "name": "enable",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Whether to enable client process statistic",
        "name": "enable_stats",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "\"30s\"",
          "oneliner": true
        },
        "desc": "The idle time of the client connection process. It has two purposes:\n  1. A newly created client process that does not receive any client requests after that time will be closed directly.\n  2. A running client process that does not receive any client requests after this time will go into hibernation to save resources.",
        "name": "idle_timeout",
        "raw_default": "30s",
        "type": {
          "kind": "primitive",
          "name": "emqx_gateway_schema:duration()"
        }
      },
      {
        "desc": "ClientInfo override.",
        "name": "clientinfo_override",
        "type": {
          "kind": "struct",
          "name": "gateway:clientinfo_override"
        }
      },
      {
        "desc": "Default authentication configs for all the gateway listeners. For per-listener overrides see <code>authentication</code>\n in listener configs",
        "examples": {
          "jwt": {
            "summary": "JWT authentication",
            "value": {
              "algorithm": "hmac-based",
              "mechanism": "jwt",
              "secret": "mysecret",
              "secret_base64_encoded": false,
              "use_jwks": false,
              "verify_claims": {
                "username": "${username}"
              }
            }
          },
          "password_based:built_in_database": {
            "summary": "Built-in password_based authentication",
            "value": {
              "backend": "built_in_database",
              "mechanism": "password_based",
              "password_hash_algorithm": {
                "name": "sha256",
                "salt_position": "suffix"
              },
              "user_id_type": "username"
            }
          },
          "password_based:http": {
            "summary": "password_based authentication through external HTTP API",
            "value": {
              "backend": "http",
              "body": {
                "password": "${password}",
                "username": "${username}"
              },
              "connect_timeout": 5000,
              "enable_pipelining": 100,
              "headers": {
                "content-type": "application/json"
              },
              "mechanism": "password_based",
              "method": "post",
              "pool_size": 8,
              "request_timeout": 5000,
              "ssl": {
                "enable": false
              },
              "url": "http://127.0.0.1:18083"
            }
          },
          "password_based:mongodb": {
            "summary": "password_based authentication with MongoDB backend",
            "value": {
              "backend": "mongodb",
              "collection": "users",
              "database": "example",
              "filter": {
                "username": "${username}"
              },
              "is_superuser_field": "is_superuser",
              "mechanism": "password_based",
              "password_hash_algorithm": {
                "name": "sha256",
                "salt_position": "suffix"
              },
              "password_hash_field": "password_hash",
              "salt_field": "salt",
              "server": "127.0.0.1:27017"
            }
          },
          "password_based:redis": {
            "summary": "password_based authentication with Redis backend",
            "value": {
              "backend": "redis",
              "cmd": "HMGET ${username} password_hash salt",
              "database": 0,
              "mechanism": "password_based",
              "password_hash_algorithm": {
                "name": "sha256",
                "salt_position": "suffix"
              },
              "redis_type": "single",
              "server": "127.0.0.1:6379"
            }
          }
        },
        "name": "authentication",
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "struct",
              "name": "authn-builtin_db:authentication"
            },
            {
              "kind": "struct",
              "name": "authn-mysql:authentication"
            },
            {
              "kind": "struct",
              "name": "authn-postgresql:authentication"
            },
            {
              "kind": "struct",
              "name": "authn-mongodb:standalone"
            },
            {
              "kind": "struct",
              "name": "authn-mongodb:replica-set"
            },
            {
              "kind": "struct",
              "name": "authn-mongodb:sharded-cluster"
            },
            {
              "kind": "struct",
              "name": "authn-redis:standalone"
            },
            {
              "kind": "struct",
              "name": "authn-redis:cluster"
            },
            {
              "kind": "struct",
              "name": "authn-redis:sentinel"
            },
            {
              "kind": "struct",
              "name": "authn-http:get"
            },
            {
              "kind": "struct",
              "name": "authn-http:post"
            },
            {
              "kind": "struct",
              "name": "authn-jwt:hmac-based"
            },
            {
              "kind": "struct",
              "name": "authn-jwt:public-key"
            },
            {
              "kind": "struct",
              "name": "authn-jwt:jwks"
            },
            {
              "kind": "struct",
              "name": "authn-scram-builtin_db:authentication"
            }
          ]
        }
      }
    ],
    "full_name": "gateway:stomp",
    "paths": [
      "gateway.stomp"
    ],
    "tags": [
      "Gateway"
    ]
  },
  {
    "desc": "Size limits for the STOMP frames.",
    "fields": [
      {
        "default": {
          "hocon": "10",
          "oneliner": true
        },
        "desc": "The maximum number of Header",
        "name": "max_headers",
        "raw_default": 10,
        "type": {
          "kind": "primitive",
          "name": "non_neg_integer()"
        }
      },
      {
        "default": {
          "hocon": "1024",
          "oneliner": true
        },
        "desc": "The maximum string length of the Header Value",
        "name": "max_headers_length",
        "raw_default": 1024,
        "type": {
          "kind": "primitive",
          "name": "non_neg_integer()"
        }
      },
      {
        "default": {
          "hocon": "65536",
          "oneliner": true
        },
        "desc": "Maximum number of bytes of Body allowed per Stomp packet",
        "name": "max_body_length",
        "raw_default": 65536,
        "type": {
          "kind": "primitive",
          "name": "integer()"
        }
      }
    ],
    "full_name": "gateway:stomp_frame",
    "paths": [
      "gateway.stomp.frame"
    ],
    "tags": [
      "Gateway"
    ]
  },
  {
    "desc": "Settings for the TCP listener.",
    "fields": [
      {
        "default": {
          "hocon": "16",
          "oneliner": true
        },
        "desc": "Size of the acceptor pool.",
        "name": "acceptors",
        "raw_default": 16,
        "type": {
          "kind": "primitive",
          "name": "integer()"
        }
      },
      {
        "desc": "Setting the TCP socket options.",
        "name": "tcp_options",
        "type": {
          "kind": "struct",
          "name": "broker:tcp_opts"
        }
      },
      {
        "default": {
          "hocon": "false",
          "oneliner": true
        },
        "desc": "Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.\nSee: https://www.haproxy.com/blog/haproxy/proxy-protocol/",
        "name": "proxy_protocol",
        "raw_default": false,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "\"15s\"",
          "oneliner": true
        },
        "desc": "Timeout for proxy protocol.\nEMQX will close the TCP connection if proxy protocol packet is not received within the timeout.",
        "name": "proxy_protocol_timeout",
        "raw_default": "15s",
        "type": {
          "kind": "primitive",
          "name": "emqx_gateway_schema:duration()"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Enable the listener.",
        "name": "enable",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "desc": "The IP address and port that the listener will bind.",
        "name": "bind",
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "primitive",
              "name": "emqx_gateway_schema:ip_port()"
            },
            {
              "kind": "primitive",
              "name": "integer()"
            }
          ]
        }
      },
      {
        "default": {
          "hocon": "1024",
          "oneliner": true
        },
        "desc": "Maximum number of concurrent connections.",
        "name": "max_connections",
        "raw_default": 1024,
        "type": {
          "kind": "primitive",
          "name": "integer()"
        }
      },
      {
        "default": {
          "hocon": "1000",
          "oneliner": true
        },
        "desc": "Maximum connections per second.",
        "name": "max_conn_rate",
        "raw_default": 1000,
        "type": {
          "kind": "primitive",
          "name": "integer()"
        }
      },
      {
        "desc": "Default authentication configs for all the gateway listeners. For per-listener overrides see <code>authentication</code>\n in listener configs",
        "examples": {
          "jwt": {
            "summary": "JWT authentication",
            "value": {
              "algorithm": "hmac-based",
              "mechanism": "jwt",
              "secret": "mysecret",
              "secret_base64_encoded": false,
              "use_jwks": false,
              "verify_claims": {
                "username": "${username}"
              }
            }
          },
          "password_based:built_in_database": {
            "summary": "Built-in password_based authentication",
            "value": {
              "backend": "built_in_database",
              "mechanism": "password_based",
              "password_hash_algorithm": {
                "name": "sha256",
                "salt_position": "suffix"
              },
              "user_id_type": "username"
            }
          },
          "password_based:http": {
            "summary": "password_based authentication through external HTTP API",
            "value": {
              "backend": "http",
              "body": {
                "password": "${password}",
                "username": "${username}"
              },
              "connect_timeout": 5000,
              "enable_pipelining": 100,
              "headers": {
                "content-type": "application/json"
              },
              "mechanism": "password_based",
              "method": "post",
              "pool_size": 8,
              "request_timeout": 5000,
              "ssl": {
                "enable": false
              },
              "url": "http://127.0.0.1:18083"
            }
          },
          "password_based:mongodb": {
            "summary": "password_based authentication with MongoDB backend",
            "value": {
              "backend": "mongodb",
              "collection": "users",
              "database": "example",
              "filter": {
                "username": "${username}"
              },
              "is_superuser_field": "is_superuser",
              "mechanism": "password_based",
              "password_hash_algorithm": {
                "name": "sha256",
                "salt_position": "suffix"
              },
              "password_hash_field": "password_hash",
              "salt_field": "salt",
              "server": "127.0.0.1:27017"
            }
          },
          "password_based:redis": {
            "summary": "password_based authentication with Redis backend",
            "value": {
              "backend": "redis",
              "cmd": "HMGET ${username} password_hash salt",
              "database": 0,
              "mechanism": "password_based",
              "password_hash_algorithm": {
                "name": "sha256",
                "salt_position": "suffix"
              },
              "redis_type": "single",
              "server": "127.0.0.1:6379"
            }
          }
        },
        "name": "authentication",
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "struct",
              "name": "authn-builtin_db:authentication"
            },
            {
              "kind": "struct",
              "name": "authn-mysql:authentication"
            },
            {
              "kind": "struct",
              "name": "authn-postgresql:authentication"
            },
            {
              "kind": "struct",
              "name": "authn-mongodb:standalone"
            },
            {
              "kind": "struct",
              "name": "authn-mongodb:replica-set"
            },
            {
              "kind": "struct",
              "name": "authn-mongodb:sharded-cluster"
            },
            {
              "kind": "struct",
              "name": "authn-redis:standalone"
            },
            {
              "kind": "struct",
              "name": "authn-redis:cluster"
            },
            {
              "kind": "struct",
              "name": "authn-redis:sentinel"
            },
            {
              "kind": "struct",
              "name": "authn-http:get"
            },
            {
              "kind": "struct",
              "name": "authn-http:post"
            },
            {
              "kind": "struct",
              "name": "authn-jwt:hmac-based"
            },
            {
              "kind": "struct",
              "name": "authn-jwt:public-key"
            },
            {
              "kind": "struct",
              "name": "authn-jwt:jwks"
            },
            {
              "kind": "struct",
              "name": "authn-scram-builtin_db:authentication"
            }
          ]
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Set <code>true</code> (default) to enable client authentication on this listener. \nWhen set to <code>false</code> clients will be allowed to connect without authentication.",
        "name": "enable_authn",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "desc": "When publishing or subscribing, prefix all topics with a mountpoint string.\nThe prefixed string will be removed from the topic name when the message is delivered to the subscriber.\nThe mountpoint is a way that users can use to implement isolation of message routing between different listeners.\nFor example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`,\nthen the client actually subscribes to the topic `some_tenant/t`.\nSimilarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`,\nthe message is routed to all the clients subscribed `some_tenant/t`,\nso client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.\nVariables in mountpoint string:<br/>\n  - <code>${clientid}</code>: clientid<br/>\n  - <code>${username}</code>: username",
        "name": "mountpoint",
        "type": {
          "kind": "primitive",
          "name": "binary()"
        }
      },
      {
        "default": {
          "hocon": "[]",
          "oneliner": true
        },
        "desc": "The access control rules for this listener.\nSee: https://github.com/emqtt/esockd#allowdeny",
        "name": "access_rules",
        "raw_default": [],
        "type": {
          "elements": {
            "kind": "primitive",
            "name": "string()"
          },
          "kind": "array"
        }
      }
    ],
    "full_name": "gateway:tcp_listener",
    "paths": [
      "gateway.exproto.listeners.tcp.$name",
      "gateway.stomp.listeners.tcp.$name"
    ],
    "tags": [
      "Gateway"
    ]
  },
  {
    "desc": "Settings for the TCP listeners.",
    "fields": [
      {
        "desc": "",
        "name": "tcp",
        "type": {
          "kind": "map",
          "name": "name",
          "values": {
            "kind": "struct",
            "name": "gateway:tcp_listener"
          }
        }
      },
      {
        "desc": "",
        "name": "ssl",
        "type": {
          "kind": "map",
          "name": "name",
          "values": {
            "kind": "struct",
            "name": "gateway:ssl_listener"
          }
        }
      }
    ],
    "full_name": "gateway:tcp_listeners",
    "paths": [
      "gateway.stomp.listeners"
    ],
    "tags": [
      "Gateway"
    ]
  },
  {
    "desc": "Settings for the listeners.",
    "fields": [
      {
        "desc": "",
        "name": "tcp",
        "type": {
          "kind": "map",
          "name": "name",
          "values": {
            "kind": "struct",
            "name": "gateway:tcp_listener"
          }
        }
      },
      {
        "desc": "",
        "name": "ssl",
        "type": {
          "kind": "map",
          "name": "name",
          "values": {
            "kind": "struct",
            "name": "gateway:ssl_listener"
          }
        }
      },
      {
        "desc": "",
        "name": "udp",
        "type": {
          "kind": "map",
          "name": "name",
          "values": {
            "kind": "struct",
            "name": "gateway:udp_listener"
          }
        }
      },
      {
        "desc": "",
        "name": "dtls",
        "type": {
          "kind": "map",
          "name": "name",
          "values": {
            "kind": "struct",
            "name": "gateway:dtls_listener"
          }
        }
      }
    ],
    "full_name": "gateway:tcp_udp_listeners",
    "paths": [
      "gateway.exproto.listeners"
    ],
    "tags": [
      "Gateway"
    ]
  },
  {
    "desc": "MQTT topic that corresponds to a particular type of event.",
    "fields": [
      {
        "desc": "Topic Name",
        "name": "topic",
        "type": {
          "kind": "primitive",
          "name": "binary()"
        }
      },
      {
        "default": {
          "hocon": "0",
          "oneliner": true
        },
        "desc": "QoS Level",
        "name": "qos",
        "raw_default": 0,
        "type": {
          "kind": "primitive",
          "name": "qos()"
        }
      }
    ],
    "full_name": "gateway:translator",
    "paths": [
      "gateway.lwm2m.translators.command",
      "gateway.lwm2m.translators.notify",
      "gateway.lwm2m.translators.register",
      "gateway.lwm2m.translators.response",
      "gateway.lwm2m.translators.update"
    ],
    "tags": [
      "Gateway"
    ]
  },
  {
    "desc": "Settings for the UDP listener.",
    "fields": [
      {
        "name": "udp_options",
        "type": {
          "kind": "struct",
          "name": "gateway:udp_opts"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Enable the listener.",
        "name": "enable",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "desc": "The IP address and port that the listener will bind.",
        "name": "bind",
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "primitive",
              "name": "emqx_gateway_schema:ip_port()"
            },
            {
              "kind": "primitive",
              "name": "integer()"
            }
          ]
        }
      },
      {
        "default": {
          "hocon": "1024",
          "oneliner": true
        },
        "desc": "Maximum number of concurrent connections.",
        "name": "max_connections",
        "raw_default": 1024,
        "type": {
          "kind": "primitive",
          "name": "integer()"
        }
      },
      {
        "default": {
          "hocon": "1000",
          "oneliner": true
        },
        "desc": "Maximum connections per second.",
        "name": "max_conn_rate",
        "raw_default": 1000,
        "type": {
          "kind": "primitive",
          "name": "integer()"
        }
      },
      {
        "desc": "Default authentication configs for all the gateway listeners. For per-listener overrides see <code>authentication</code>\n in listener configs",
        "examples": {
          "jwt": {
            "summary": "JWT authentication",
            "value": {
              "algorithm": "hmac-based",
              "mechanism": "jwt",
              "secret": "mysecret",
              "secret_base64_encoded": false,
              "use_jwks": false,
              "verify_claims": {
                "username": "${username}"
              }
            }
          },
          "password_based:built_in_database": {
            "summary": "Built-in password_based authentication",
            "value": {
              "backend": "built_in_database",
              "mechanism": "password_based",
              "password_hash_algorithm": {
                "name": "sha256",
                "salt_position": "suffix"
              },
              "user_id_type": "username"
            }
          },
          "password_based:http": {
            "summary": "password_based authentication through external HTTP API",
            "value": {
              "backend": "http",
              "body": {
                "password": "${password}",
                "username": "${username}"
              },
              "connect_timeout": 5000,
              "enable_pipelining": 100,
              "headers": {
                "content-type": "application/json"
              },
              "mechanism": "password_based",
              "method": "post",
              "pool_size": 8,
              "request_timeout": 5000,
              "ssl": {
                "enable": false
              },
              "url": "http://127.0.0.1:18083"
            }
          },
          "password_based:mongodb": {
            "summary": "password_based authentication with MongoDB backend",
            "value": {
              "backend": "mongodb",
              "collection": "users",
              "database": "example",
              "filter": {
                "username": "${username}"
              },
              "is_superuser_field": "is_superuser",
              "mechanism": "password_based",
              "password_hash_algorithm": {
                "name": "sha256",
                "salt_position": "suffix"
              },
              "password_hash_field": "password_hash",
              "salt_field": "salt",
              "server": "127.0.0.1:27017"
            }
          },
          "password_based:redis": {
            "summary": "password_based authentication with Redis backend",
            "value": {
              "backend": "redis",
              "cmd": "HMGET ${username} password_hash salt",
              "database": 0,
              "mechanism": "password_based",
              "password_hash_algorithm": {
                "name": "sha256",
                "salt_position": "suffix"
              },
              "redis_type": "single",
              "server": "127.0.0.1:6379"
            }
          }
        },
        "name": "authentication",
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "struct",
              "name": "authn-builtin_db:authentication"
            },
            {
              "kind": "struct",
              "name": "authn-mysql:authentication"
            },
            {
              "kind": "struct",
              "name": "authn-postgresql:authentication"
            },
            {
              "kind": "struct",
              "name": "authn-mongodb:standalone"
            },
            {
              "kind": "struct",
              "name": "authn-mongodb:replica-set"
            },
            {
              "kind": "struct",
              "name": "authn-mongodb:sharded-cluster"
            },
            {
              "kind": "struct",
              "name": "authn-redis:standalone"
            },
            {
              "kind": "struct",
              "name": "authn-redis:cluster"
            },
            {
              "kind": "struct",
              "name": "authn-redis:sentinel"
            },
            {
              "kind": "struct",
              "name": "authn-http:get"
            },
            {
              "kind": "struct",
              "name": "authn-http:post"
            },
            {
              "kind": "struct",
              "name": "authn-jwt:hmac-based"
            },
            {
              "kind": "struct",
              "name": "authn-jwt:public-key"
            },
            {
              "kind": "struct",
              "name": "authn-jwt:jwks"
            },
            {
              "kind": "struct",
              "name": "authn-scram-builtin_db:authentication"
            }
          ]
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Set <code>true</code> (default) to enable client authentication on this listener. \nWhen set to <code>false</code> clients will be allowed to connect without authentication.",
        "name": "enable_authn",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "desc": "When publishing or subscribing, prefix all topics with a mountpoint string.\nThe prefixed string will be removed from the topic name when the message is delivered to the subscriber.\nThe mountpoint is a way that users can use to implement isolation of message routing between different listeners.\nFor example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`,\nthen the client actually subscribes to the topic `some_tenant/t`.\nSimilarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`,\nthe message is routed to all the clients subscribed `some_tenant/t`,\nso client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.\nVariables in mountpoint string:<br/>\n  - <code>${clientid}</code>: clientid<br/>\n  - <code>${username}</code>: username",
        "name": "mountpoint",
        "type": {
          "kind": "primitive",
          "name": "binary()"
        }
      },
      {
        "default": {
          "hocon": "[]",
          "oneliner": true
        },
        "desc": "The access control rules for this listener.\nSee: https://github.com/emqtt/esockd#allowdeny",
        "name": "access_rules",
        "raw_default": [],
        "type": {
          "elements": {
            "kind": "primitive",
            "name": "string()"
          },
          "kind": "array"
        }
      }
    ],
    "full_name": "gateway:udp_listener",
    "paths": [
      "gateway.coap.listeners.udp.$name",
      "gateway.exproto.listeners.udp.$name",
      "gateway.lwm2m.listeners.udp.$name",
      "gateway.mqttsn.listeners.udp.$name"
    ],
    "tags": [
      "Gateway"
    ]
  },
  {
    "desc": "Settings for the UDP listeners.",
    "fields": [
      {
        "desc": "",
        "name": "udp",
        "type": {
          "kind": "map",
          "name": "name",
          "values": {
            "kind": "struct",
            "name": "gateway:udp_listener"
          }
        }
      },
      {
        "desc": "",
        "name": "dtls",
        "type": {
          "kind": "map",
          "name": "name",
          "values": {
            "kind": "struct",
            "name": "gateway:dtls_listener"
          }
        }
      }
    ],
    "full_name": "gateway:udp_listeners",
    "paths": [
      "gateway.coap.listeners",
      "gateway.lwm2m.listeners",
      "gateway.mqttsn.listeners"
    ],
    "tags": [
      "Gateway"
    ]
  },
  {
    "desc": "Settings for the UDP sockets.",
    "fields": [
      {
        "default": {
          "hocon": "100",
          "oneliner": true
        },
        "desc": "Specify the {active, N} option for the socket.\nSee: https://erlang.org/doc/man/inet.html#setopts-2",
        "name": "active_n",
        "raw_default": 100,
        "type": {
          "kind": "primitive",
          "name": "integer()"
        }
      },
      {
        "desc": "Size of the kernel-space receive buffer for the socket.",
        "name": "recbuf",
        "type": {
          "kind": "primitive",
          "name": "emqx_gateway_schema:bytesize()"
        }
      },
      {
        "desc": "Size of the kernel-space send buffer for the socket.",
        "name": "sndbuf",
        "type": {
          "kind": "primitive",
          "name": "emqx_gateway_schema:bytesize()"
        }
      },
      {
        "desc": "Size of the user-space buffer for the socket.",
        "name": "buffer",
        "type": {
          "kind": "primitive",
          "name": "emqx_gateway_schema:bytesize()"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Allow local reuse of port numbers.",
        "name": "reuseaddr",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      }
    ],
    "full_name": "gateway:udp_opts",
    "paths": [
      "gateway.coap.listeners.dtls.$name.udp_options",
      "gateway.coap.listeners.udp.$name.udp_options",
      "gateway.exproto.listeners.dtls.$name.udp_options",
      "gateway.exproto.listeners.udp.$name.udp_options",
      "gateway.lwm2m.listeners.dtls.$name.udp_options",
      "gateway.lwm2m.listeners.udp.$name.udp_options",
      "gateway.mqttsn.listeners.dtls.$name.udp_options",
      "gateway.mqttsn.listeners.udp.$name.udp_options"
    ],
    "tags": [
      "Gateway"
    ]
  }
]